// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;
import { IERC20 } from "../../src/interfaces/IERC20.sol";

import "forge-std/Test.sol";

contract DAOWallet is Test {
  mapping(address => uint256) public balances;
  mapping(address => uint256) public ethBalances;

  function deposit() public payable {
    ethBalances[msg.sender] += (msg.value);
  }

  function deposit(address token, uint256 amount) public {
    IERC20(token).transferFrom(msg.sender, address(this), amount);
    balances[msg.sender] += amount;
  }

  function balanceOf(address _who) public view returns (uint256 balance) {
    return ethBalances[_who];
  }

  function balanceOf(address _who, address _token)
    public
    view
    returns (uint256 balance)
  {
    return balances[_who];
  }

  function withdrawETH(uint256 _amount) public {
    require(ethBalances[msg.sender] >= _amount, "INSUFFICIENT_FUNDS");
    emit log_named_uint("hacker balance to start", ethBalances[msg.sender]);

    (bool result, ) = msg.sender.call{ value: _amount }("");
    require(result, "WITHDRAW_FAILED");

    emit log_named_uint("contract balance before", address(this).balance);
    emit log_named_uint("hacker balance before decrement", ethBalances[msg.sender]);
    // this is the attack- decrement after withdraw
    ethBalances[msg.sender] -= _amount;
    emit log_named_uint("contract balance after", address(this).balance);
    emit log_named_uint("hacker balance after decrement", ethBalances[msg.sender]);
  }

  function withdraw(address token, uint256 _amount) public {
    // if the user has enough balance to withdraw
    require(balances[msg.sender] >= _amount, "INSUFFICIENT_FUNDS");

    IERC20(token).transferFrom(address(this), msg.sender, _amount);
    balances[msg.sender] -= _amount;
  }

  function getContractBalance() public returns (uint) {
    return address(this).balance;
  }

  receive() external payable {}
}
