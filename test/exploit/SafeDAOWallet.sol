// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {CypherEscrow} from "../../src/CypherEscrow.sol";
import {CypherVault} from "../../src/CypherVault.sol";
import {CypherRegistry} from "../../src/CypherRegistry.sol";
import {IERC20} from "../../src/interfaces/IERC20.sol";

contract SafeDAOWallet is CypherVault {
  address registry;

  /// @notice Balances of the users
  mapping(address => uint256) public balances;

  /// @notice Transaction threshold for
  uint256 txThreshold = 10;

  constructor(address _delegator, address _cypherRegistry)
    CypherVault(_delegator)
  {
    registry = _cypherRegistry;
  }

  function deposit(address token, uint256 amount) public {
    bool result = IERC20(token).transferFrom(msg.sender, address(this), amount);
    require(result, "Transfer did not work");
    balances[msg.sender] += amount;
  }

  function balanceOf(address _who) public view returns (uint256 balance) {
    return balances[_who];
  }

  function withdraw(address token, uint256 _amount) public {
    // if the user has enough balance to withdraw
    require(balances[msg.sender] >= _amount, "INSUFFICIENT_FUNDS");

    balances[msg.sender] -= _amount;
    // pass msg.value along to escrow
    CypherEscrow escrow = CypherEscrow(
      CypherRegistry(registry).getEscrowForProtocol(address(this))
    );

    IERC20(token).approve(address(escrow), _amount);
    escrow.escrowTokens(msg.sender, token, _amount, 1);
  }

  receive() external payable {}
}
