// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;
import { IERC20 } from "../../src/interfaces/IERC20.sol";
import { ICypherEscrow } from "../../src/interfaces/ICypherEscrow.sol";
import { CypherVault } from "../../src/CypherVault.sol";

contract SafeDAOWallet is CypherVault {
  mapping(address => uint256) public balances;
  mapping(address => uint256) public ethBalances;

  constructor(address delegator, address registry)
    CypherVault(delegator, registry)
  {}

  function deposit() public payable {
    ethBalances[msg.sender] += (msg.value);
  }

  function deposit(address token, uint256 amount) public {
    IERC20(token).transferFrom(msg.sender, address(this), amount);
    balances[msg.sender] += amount;
  }

  function balanceOf(address _who) public view returns (uint256 balance) {
    return ethBalances[_who];
  }

  function balanceOf(address _who, address _token)
    public
    view
    returns (uint256 balance)
  {
    return balances[_who];
  }

  function withdraw(uint256 _amount) public {
    require(balances[msg.sender] >= _amount, "INSUFFICIENT_FUNDS");

    ICypherEscrow escrow = ICypherEscrow(getEscrow());
    escrow.escrowETH(msg.sender, _amount, 1);

    // this is the attack- decrement after withdraw
    ethBalances[msg.sender] -= _amount;
  }

  function withdraw(address token, uint256 _amount) public {
    // if the user has enough balance to withdraw
    require(balances[msg.sender] >= _amount, "INSUFFICIENT_FUNDS");

    ICypherEscrow escrow = ICypherEscrow(getEscrow());
    IERC20(token).approve(address(escrow), _amount);
    escrow.escrowTokens(msg.sender, token, _amount, 1);

    balances[msg.sender] -= _amount;
  }

  receive() external payable {}
}
