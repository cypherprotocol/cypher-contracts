// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {CypherEscrow} from "../../src/CypherEscrow.sol";
import {CypherVault} from "../../src/CypherVault.sol";
import {CypherRegistry} from "../../src/CypherRegistry.sol";
import {ICypherEscrow} from "../../src/interfaces/ICypherEscrow.sol";
import {IERC20} from "../../src/interfaces/IERC20.sol";

contract SafeDAOWallet is CypherVault {
  /// @notice Balances of the users
  mapping(address => uint256) public balances;

  /// @notice Transaction threshold for
  uint256 txThreshold = 10;

  constructor(address _delegator, address _cypherRegistry)
    CypherVault(_delegator, _cypherRegistry)
  {}

  function deposit(address token, uint256 amount) public {
    IERC20(token).transferFrom(msg.sender, address(this), amount);
    balances[msg.sender] += amount;
  }

  function balanceOf(address _who) public view returns (uint256 balance) {
    return balances[_who];
  }

  function withdraw(address token, uint256 _amount) public {
    // if the user has enough balance to withdraw
    require(balances[msg.sender] >= _amount, "INSUFFICIENT_FUNDS");

    balances[msg.sender] -= _amount;
    // pass msg.value along to escrow

    ICypherEscrow escrow = ICypherEscrow(getEscrow());
    IERC20(token).approve(address(escrow), _amount);
    escrow.escrowTokens(msg.sender, token, _amount, 1);
  }

  receive() external payable {}
}
