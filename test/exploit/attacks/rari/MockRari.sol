/// fERC20127: https://etherscan.io/address/0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47#contracts -- need deposit()
/// fETH127: https://etherscan.io/address/0x26267e41CeCa7C8E0f143554Af707336f27Fa051#contracts -- need borrow()
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";

import { Bool } from "../../../lib/BoolTool.sol";
import { IERC20 } from "../../../../src/interfaces/IERC20.sol";

contract MockRari is Test {
    mapping(address => uint) internal accountBorrows;
    address public token;

    constructor(address _token) {
        token = _token;
    }

    // function borrow(address payable borrower, uint borrowAmount) public returns (uint) {
    //     emit log_string("in borrow");
    //     doTransferOut(borrower, borrowAmount);
    //     emit log_string("after doTransferOut");
    //     emit log_named_uint("accountBorrows[borrower]", accountBorrows[borrower]);
    //     emit log_named_uint("borrowAmount", borrowAmount);
    //     // accountBorrows[borrower] -= borrowAmount;
    //     accountBorrows[borrower] -= borrowAmount;
    //     emit log_string("after decrement");
    //     return accountBorrows[borrower];
    // }

    function borrow() public payable returns (uint) {
        (bool success, ) = msg.sender.call{value: accountBorrows[msg.sender]}("");

        emit log_named_uint("success", Bool.toUint256(success));
        require(success, "doTransferOut failed");

        // this is the attack- decrement AFTER withdraw (should be before)
        accountBorrows[msg.sender] = 0;
    }

    function depositTokens(uint amount) external {
        require(amount > 0, "Need more deposited");

        IERC20(token).transferFrom(msg.sender, address(this), amount);

        // update the account balances locally
        accountBorrows[msg.sender] += amount;
    }

    /**
     * @notice Perform the actual transfer in, which is a no-op
     * @param from Address sending the Ether
     * @param amount Amount of Ether being sent
     * @return The actual amount of Ether transferred
     */
    function doTransferIn(address from, uint amount) internal returns (uint) {
        // Sanity checks
        require(msg.sender == from, "sender mismatch");
        require(msg.value == amount, "value mismatch");
        return amount;
    }

    function doTransferOut(address payable to, uint amount) internal {
        // Send the Ether and revert on failure
        (bool success, ) = to.call{value: accountBorrows[msg.sender]}("");
        require(success, "doTransferOut failed");

        // this is the attack- decrement AFTER withdraw (should be before)
        accountBorrows[msg.sender] -= amount;
    }

    function getContractBalance() external returns (uint) {
        return address(this).balance;
    }

    function depositInitialEtherForTest() external payable returns (uint) {
        return address(this).balance;
    }
}