/// fERC20127: https://etherscan.io/address/0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47#contracts -- need deposit()
/// fETH127: https://etherscan.io/address/0x26267e41CeCa7C8E0f143554Af707336f27Fa051#contracts -- need borrow()

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import { CypherEscrow } from "../../../../src/CypherEscrow.sol";

contract MockRariCypher {
    mapping(address => uint) internal accountBorrows;

    constructor() {}

    function borrow(address payable borrower, uint borrowAmount) internal returns (uint) {
        doTransferOut(borrower, borrowAmount);
        accountBorrows[borrower] -= borrowAmount;
        return accountBorrows[borrower];
    }

    /**
     * @notice Perform the actual transfer in, which is a no-op
     * @param from Address sending the Ether
     * @param amount Amount of Ether being sent
     * @return The actual amount of Ether transferred
     */
    function doTransferIn(address from, uint amount) internal returns (uint) {
        // Sanity checks
        require(msg.sender == from, "sender mismatch");
        require(msg.value == amount, "value mismatch");
        return amount;
    }

    function doTransferOut(address payable to, uint amount) internal {
        // Send the Ether and revert on failure
        (bool success, ) = to.call{value: amount}("");
        require(success, "doTransferOut failed");
    }
}