/// fERC20127: https://etherscan.io/address/0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47#contracts -- need deposit()
/// fETH127: https://etherscan.io/address/0x26267e41CeCa7C8E0f143554Af707336f27Fa051#contracts -- need borrow()
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";

import {Bool} from "../../../lib/BoolTool.sol";
import {IERC20} from "../../../../src/interfaces/IERC20.sol";
import {ICypherEscrow} from "../../../../src/interfaces/ICypherEscrow.sol";
import {CypherProtocol} from "../../../../src/CypherProtocol.sol";

contract SafeMockRari is CypherProtocol, Test {
    mapping(address => uint256) internal accountDeposits;
    address public token;

    constructor(
        address _token,
        address deployer,
        address registry
    ) CypherProtocol("Rari", deployer, registry) {
        token = _token;
    }

    function depositTokens(uint256 amount) external {
        require(amount > 0, "Need more deposited");

        IERC20(token).transferFrom(msg.sender, address(this), amount);

        accountDeposits[msg.sender] += amount;
    }

    function borrow() public payable returns (uint256) {
        require(accountDeposits[msg.sender] >= 0, "INSUFFICIENT_FUNDS");

        ICypherEscrow escrow = ICypherEscrow(getEscrow());
        escrow.escrowETH{value: accountDeposits[msg.sender]}(msg.sender, msg.sender);

        accountDeposits[msg.sender] = 0;
    }

    receive() external payable {}
}
